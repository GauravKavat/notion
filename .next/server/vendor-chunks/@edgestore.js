"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@edgestore";
exports.ids = ["vendor-chunks/@edgestore"];
exports.modules = {

/***/ "(ssr)/./node_modules/@edgestore/react/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@edgestore/react/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEdgeStoreProvider: () => (/* binding */ createEdgeStoreProvider)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _edgestore_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @edgestore/shared */ \"(ssr)/./node_modules/@edgestore/shared/dist/index.mjs\");\n/* harmony import */ var _uploadAbortedError_e1379bb0_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./uploadAbortedError-e1379bb0.mjs */ \"(ssr)/./node_modules/@edgestore/react/dist/uploadAbortedError-e1379bb0.mjs\");\n\n\n\n\nclass EdgeStoreClientError extends Error {\n    constructor(message){\n        super(message);\n        this.name = 'EdgeStoreError';\n    }\n}\n\nasync function handleError(res) {\n    let json = {};\n    try {\n        json = await res.json();\n    } catch (err) {\n        throw new EdgeStoreClientError(`Failed to parse response. Make sure the api is correctly configured at ${res.url}`);\n    }\n    throw new _edgestore_shared__WEBPACK_IMPORTED_MODULE_1__.EdgeStoreApiClientError({\n        response: json\n    });\n}\n\nfunction createNextProxy({ apiPath, uploadingCountRef, maxConcurrentUploads = 5 }) {\n    return new Proxy({}, {\n        get (_, prop) {\n            const bucketName = prop;\n            const bucketFunctions = {\n                upload: async (params)=>{\n                    try {\n                        params.onProgressChange?.(0);\n                        // This handles the case where the user cancels the upload while it's waiting in the queue\n                        const abortPromise = new Promise((resolve)=>{\n                            params.signal?.addEventListener('abort', ()=>{\n                                resolve();\n                            }, {\n                                once: true\n                            });\n                        });\n                        while(uploadingCountRef.current >= maxConcurrentUploads && uploadingCountRef.current > 0){\n                            await Promise.race([\n                                new Promise((resolve)=>setTimeout(resolve, 300)),\n                                abortPromise\n                            ]);\n                            if (params.signal?.aborted) {\n                                throw new _uploadAbortedError_e1379bb0_mjs__WEBPACK_IMPORTED_MODULE_2__.U('File upload aborted');\n                            }\n                        }\n                        uploadingCountRef.current++;\n                        const fileInfo = await uploadFile(params, {\n                            bucketName: bucketName,\n                            apiPath\n                        });\n                        return fileInfo;\n                    } finally{\n                        uploadingCountRef.current--;\n                    }\n                },\n                confirmUpload: async (params)=>{\n                    const { success } = await confirmUpload(params, {\n                        bucketName: bucketName,\n                        apiPath\n                    });\n                    if (!success) {\n                        throw new EdgeStoreClientError('Failed to confirm upload');\n                    }\n                },\n                delete: async (params)=>{\n                    const { success } = await deleteFile(params, {\n                        bucketName: bucketName,\n                        apiPath\n                    });\n                    if (!success) {\n                        throw new EdgeStoreClientError('Failed to delete file');\n                    }\n                }\n            };\n            return bucketFunctions;\n        }\n    });\n}\nasync function uploadFile({ file, signal, input, onProgressChange, options }, { apiPath, bucketName }) {\n    try {\n        onProgressChange?.(0);\n        const res = await fetch(`${apiPath}/request-upload`, {\n            method: 'POST',\n            credentials: 'include',\n            signal: signal,\n            body: JSON.stringify({\n                bucketName,\n                input,\n                fileInfo: {\n                    extension: file.name.split('.').pop(),\n                    type: file.type,\n                    size: file.size,\n                    fileName: options?.manualFileName,\n                    replaceTargetUrl: options?.replaceTargetUrl,\n                    temporary: options?.temporary\n                }\n            }),\n            headers: {\n                'Content-Type': 'application/json'\n            }\n        });\n        if (!res.ok) {\n            await handleError(res);\n        }\n        const json = await res.json();\n        if ('multipart' in json) {\n            await multipartUpload({\n                bucketName,\n                multipartInfo: json.multipart,\n                onProgressChange,\n                signal,\n                file,\n                apiPath\n            });\n        } else if ('uploadUrl' in json) {\n            // Single part upload\n            // Upload the file to the signed URL and get the progress\n            await uploadFileInner({\n                file,\n                uploadUrl: json.uploadUrl,\n                onProgressChange,\n                signal\n            });\n        } else {\n            throw new EdgeStoreClientError('An error occurred');\n        }\n        return {\n            url: getUrl(json.accessUrl, apiPath),\n            thumbnailUrl: json.thumbnailUrl ? getUrl(json.thumbnailUrl, apiPath) : null,\n            size: json.size,\n            uploadedAt: new Date(json.uploadedAt),\n            path: json.path,\n            pathOrder: json.pathOrder,\n            metadata: json.metadata\n        };\n    } catch (e) {\n        if (e instanceof Error && e.name === 'AbortError') {\n            throw new _uploadAbortedError_e1379bb0_mjs__WEBPACK_IMPORTED_MODULE_2__.U('File upload aborted');\n        }\n        onProgressChange?.(0);\n        throw e;\n    }\n}\n/**\n * Protected files need third-party cookies to work.\n * Since third party cookies don't work on localhost,\n * we need to proxy the file through the server.\n */ function getUrl(url, apiPath) {\n    const mode = typeof process !== 'undefined' ? \"development\" :  false ? 0 : 'production';\n    if (mode === 'development' && !url.includes('/_public/')) {\n        const proxyUrl = new URL(window.location.origin);\n        proxyUrl.pathname = `${apiPath}/proxy-file`;\n        proxyUrl.search = new URLSearchParams({\n            url\n        }).toString();\n        return proxyUrl.toString();\n    }\n    return url;\n}\nasync function uploadFileInner(props) {\n    const { file, uploadUrl, onProgressChange, signal } = props;\n    const promise = new Promise((resolve, reject)=>{\n        if (signal?.aborted) {\n            reject(new _uploadAbortedError_e1379bb0_mjs__WEBPACK_IMPORTED_MODULE_2__.U('File upload aborted'));\n            return;\n        }\n        const request = new XMLHttpRequest();\n        request.open('PUT', uploadUrl);\n        // This is for Azure provider. Specifies the blob type\n        request.setRequestHeader('x-ms-blob-type', 'BlockBlob');\n        request.addEventListener('loadstart', ()=>{\n            onProgressChange?.(0);\n        });\n        request.upload.addEventListener('progress', (e)=>{\n            if (e.lengthComputable) {\n                // 2 decimal progress\n                const progress = Math.round(e.loaded / e.total * 10000) / 100;\n                onProgressChange?.(progress);\n            }\n        });\n        request.addEventListener('error', ()=>{\n            reject(new Error('Error uploading file'));\n        });\n        request.addEventListener('abort', ()=>{\n            reject(new _uploadAbortedError_e1379bb0_mjs__WEBPACK_IMPORTED_MODULE_2__.U('File upload aborted'));\n        });\n        request.addEventListener('loadend', ()=>{\n            // Return the ETag header (needed to complete multipart upload)\n            resolve(request.getResponseHeader('ETag'));\n        });\n        if (signal) {\n            signal.addEventListener('abort', ()=>{\n                request.abort();\n            });\n        }\n        request.send(file);\n    });\n    return promise;\n}\nasync function multipartUpload(params) {\n    const { bucketName, multipartInfo, onProgressChange, file, signal, apiPath } = params;\n    const { partSize, parts, totalParts, uploadId, key } = multipartInfo;\n    const uploadingParts = [];\n    const uploadPart = async (params)=>{\n        const { part, chunk } = params;\n        const { uploadUrl } = part;\n        const eTag = await uploadFileInner({\n            file: chunk,\n            uploadUrl,\n            signal,\n            onProgressChange: (progress)=>{\n                const uploadingPart = uploadingParts.find((p)=>p.partNumber === part.partNumber);\n                if (uploadingPart) {\n                    uploadingPart.progress = progress;\n                } else {\n                    uploadingParts.push({\n                        partNumber: part.partNumber,\n                        progress\n                    });\n                }\n                const totalProgress = Math.round(uploadingParts.reduce((acc, p)=>acc + p.progress * 100, 0) / totalParts) / 100;\n                onProgressChange?.(totalProgress);\n            }\n        });\n        if (!eTag) {\n            throw new EdgeStoreClientError('Could not get ETag from multipart response');\n        }\n        return {\n            partNumber: part.partNumber,\n            eTag\n        };\n    };\n    // Upload the parts in parallel\n    const completedParts = await queuedPromises({\n        items: parts.map((part)=>({\n                part,\n                chunk: file.slice((part.partNumber - 1) * partSize, part.partNumber * partSize)\n            })),\n        fn: uploadPart,\n        maxParallel: 5,\n        maxRetries: 10\n    });\n    // Complete multipart upload\n    const res = await fetch(`${apiPath}/complete-multipart-upload`, {\n        method: 'POST',\n        credentials: 'include',\n        body: JSON.stringify({\n            bucketName,\n            uploadId,\n            key,\n            parts: completedParts\n        }),\n        headers: {\n            'Content-Type': 'application/json'\n        }\n    });\n    if (!res.ok) {\n        await handleError(res);\n    }\n}\nasync function confirmUpload({ url }, { apiPath, bucketName }) {\n    const res = await fetch(`${apiPath}/confirm-upload`, {\n        method: 'POST',\n        credentials: 'include',\n        body: JSON.stringify({\n            url,\n            bucketName\n        }),\n        headers: {\n            'Content-Type': 'application/json'\n        }\n    });\n    if (!res.ok) {\n        await handleError(res);\n    }\n    return res.json();\n}\nasync function deleteFile({ url }, { apiPath, bucketName }) {\n    const res = await fetch(`${apiPath}/delete-file`, {\n        method: 'POST',\n        credentials: 'include',\n        body: JSON.stringify({\n            url,\n            bucketName\n        }),\n        headers: {\n            'Content-Type': 'application/json'\n        }\n    });\n    if (!res.ok) {\n        await handleError(res);\n    }\n    return res.json();\n}\nasync function queuedPromises({ items, fn, maxParallel, maxRetries = 0 }) {\n    const results = new Array(items.length);\n    const executeWithRetry = async (func, retries)=>{\n        try {\n            return await func();\n        } catch (error) {\n            if (error instanceof _uploadAbortedError_e1379bb0_mjs__WEBPACK_IMPORTED_MODULE_2__.U) {\n                throw error;\n            }\n            if (retries > 0) {\n                await new Promise((resolve)=>setTimeout(resolve, 5000));\n                return executeWithRetry(func, retries - 1);\n            } else {\n                throw error;\n            }\n        }\n    };\n    const semaphore = {\n        count: maxParallel,\n        async wait () {\n            // If we've reached our maximum concurrency, or it's the last item, wait\n            while(this.count <= 0)await new Promise((resolve)=>setTimeout(resolve, 500));\n            this.count--;\n        },\n        signal () {\n            this.count++;\n        }\n    };\n    const tasks = items.map((item, i)=>(async ()=>{\n            await semaphore.wait();\n            try {\n                const result = await executeWithRetry(()=>fn(item), maxRetries);\n                results[i] = result;\n            } finally{\n                semaphore.signal();\n            }\n        })());\n    await Promise.all(tasks);\n    return results;\n}\n\nconst DEFAULT_BASE_URL = (typeof process !== 'undefined' ? process.env.NEXT_PUBLIC_EDGE_STORE_BASE_URL :  undefined) ?? 'https://files.edgestore.dev';\nfunction createEdgeStoreProvider(opts) {\n    const EdgeStoreContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(undefined);\n    const EdgeStoreProvider = ({ children, basePath })=>{\n        return EdgeStoreProviderInner({\n            children,\n            context: EdgeStoreContext,\n            basePath,\n            maxConcurrentUploads: opts?.maxConcurrentUploads\n        });\n    };\n    function useEdgeStore() {\n        if (!EdgeStoreContext) {\n            throw new Error('React Context is unavailable in Server Components');\n        }\n        // @ts-expect-error - We know that the context value should not be undefined\n        const value = react__WEBPACK_IMPORTED_MODULE_0__.useContext(EdgeStoreContext);\n        if (!value && \"development\" !== 'production') {\n            throw new Error('[edgestore]: `useEdgeStore` must be wrapped in a <EdgeStoreProvider />');\n        }\n        return value;\n    }\n    return {\n        EdgeStoreProvider,\n        useEdgeStore\n    };\n}\nfunction EdgeStoreProviderInner({ children, context, basePath, maxConcurrentUploads }) {\n    const apiPath = basePath ? `${basePath}` : '/api/edgestore';\n    const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        loading: true,\n        initialized: false,\n        error: false\n    });\n    const uploadingCountRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);\n    const initExecuted = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false); // to make sure we don't run init twice\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!initExecuted.current) {\n            void init();\n        }\n        return ()=>{\n            initExecuted.current = true;\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    async function init() {\n        try {\n            setState({\n                loading: true,\n                initialized: false,\n                error: false\n            });\n            const res = await fetch(`${apiPath}/init`, {\n                method: 'POST',\n                credentials: 'include'\n            });\n            if (res.ok) {\n                const json = await res.json();\n                const innerRes = await fetch(`${DEFAULT_BASE_URL}/_init`, {\n                    method: 'GET',\n                    credentials: 'include',\n                    headers: {\n                        'x-edgestore-token': json.token\n                    }\n                });\n                if (innerRes.ok) {\n                    // update state\n                    setState({\n                        loading: false,\n                        initialized: true,\n                        error: false\n                    });\n                } else {\n                    setState({\n                        loading: false,\n                        initialized: false,\n                        error: true\n                    });\n                    throw new EdgeStoreClientError(\"Couldn't initialize Edge Store.\");\n                }\n            } else {\n                setState({\n                    loading: false,\n                    initialized: false,\n                    error: true\n                });\n                await handleError(res);\n            }\n        } catch (err) {\n            setState({\n                loading: false,\n                initialized: false,\n                error: true\n            });\n            throw err;\n        }\n    }\n    async function reset() {\n        await init();\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(context.Provider, {\n        value: {\n            edgestore: createNextProxy({\n                apiPath,\n                uploadingCountRef,\n                maxConcurrentUploads\n            }),\n            reset,\n            state\n        }\n    }, children));\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGVkZ2VzdG9yZS9yZWFjdC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQStCO0FBQzZCO0FBQ2dCOztBQUU1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04saUhBQWlILFFBQVE7QUFDekg7QUFDQSxjQUFjLHNFQUF1QjtBQUNyQztBQUNBLEtBQUs7QUFDTDs7QUFFQSwyQkFBMkIsc0RBQXNEO0FBQ2pGLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLDZCQUE2QjtBQUM3Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLCtEQUFrQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDRCQUE0QixnREFBZ0QsSUFBSSxxQkFBcUI7QUFDckc7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxzQkFBc0IsK0RBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGFBQW9CLEdBQUcsTUFBb0IsR0FBRyxDQUFhO0FBQzdHO0FBQ0E7QUFDQSwrQkFBK0IsUUFBUTtBQUN2QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRDQUE0QztBQUN4RDtBQUNBO0FBQ0EsdUJBQXVCLCtEQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsdUJBQXVCLCtEQUFrQjtBQUN6QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUVBQXFFO0FBQ2pGLFlBQVksNkNBQTZDO0FBQ3pEO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QixnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwrQkFBK0IsUUFBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsS0FBSyxJQUFJLHFCQUFxQjtBQUM3RCwrQkFBK0IsUUFBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLEtBQUssSUFBSSxxQkFBcUI7QUFDMUQsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx3Q0FBd0M7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsaUNBQWlDLCtEQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQSx5R0FBeUcsVUFBb0M7QUFDN0k7QUFDQSwyQ0FBMkMsZ0RBQW1CO0FBQzlELGlDQUFpQyxvQkFBb0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNkNBQWdCO0FBQ3RDLHNCQUFzQixhQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsbURBQW1EO0FBQ3JGLGtDQUFrQyxTQUFTO0FBQzNDLDhCQUE4QiwyQ0FBYztBQUM1QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsOEJBQThCLHlDQUFZO0FBQzFDLHlCQUF5Qix5Q0FBWSxTQUFTO0FBQzlDLElBQUksNENBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGdEQUFnRCxpQkFBaUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0RBQW1CLENBQUMsMkNBQWMsc0JBQXNCLGdEQUFtQjtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3Rpb24tY2xvbmUvLi9ub2RlX21vZHVsZXMvQGVkZ2VzdG9yZS9yZWFjdC9kaXN0L2luZGV4Lm1qcz81MmJhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEVkZ2VTdG9yZUFwaUNsaWVudEVycm9yIH0gZnJvbSAnQGVkZ2VzdG9yZS9zaGFyZWQnO1xuaW1wb3J0IHsgVSBhcyBVcGxvYWRBYm9ydGVkRXJyb3IgfSBmcm9tICcuL3VwbG9hZEFib3J0ZWRFcnJvci1lMTM3OWJiMC5tanMnO1xuXG5jbGFzcyBFZGdlU3RvcmVDbGllbnRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKXtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdFZGdlU3RvcmVFcnJvcic7XG4gICAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBoYW5kbGVFcnJvcihyZXMpIHtcbiAgICBsZXQganNvbiA9IHt9O1xuICAgIHRyeSB7XG4gICAgICAgIGpzb24gPSBhd2FpdCByZXMuanNvbigpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBuZXcgRWRnZVN0b3JlQ2xpZW50RXJyb3IoYEZhaWxlZCB0byBwYXJzZSByZXNwb25zZS4gTWFrZSBzdXJlIHRoZSBhcGkgaXMgY29ycmVjdGx5IGNvbmZpZ3VyZWQgYXQgJHtyZXMudXJsfWApO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRWRnZVN0b3JlQXBpQ2xpZW50RXJyb3Ioe1xuICAgICAgICByZXNwb25zZToganNvblxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOZXh0UHJveHkoeyBhcGlQYXRoLCB1cGxvYWRpbmdDb3VudFJlZiwgbWF4Q29uY3VycmVudFVwbG9hZHMgPSA1IH0pIHtcbiAgICByZXR1cm4gbmV3IFByb3h5KHt9LCB7XG4gICAgICAgIGdldCAoXywgcHJvcCkge1xuICAgICAgICAgICAgY29uc3QgYnVja2V0TmFtZSA9IHByb3A7XG4gICAgICAgICAgICBjb25zdCBidWNrZXRGdW5jdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgdXBsb2FkOiBhc3luYyAocGFyYW1zKT0+e1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLm9uUHJvZ3Jlc3NDaGFuZ2U/LigwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaGFuZGxlcyB0aGUgY2FzZSB3aGVyZSB0aGUgdXNlciBjYW5jZWxzIHRoZSB1cGxvYWQgd2hpbGUgaXQncyB3YWl0aW5nIGluIHRoZSBxdWV1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWJvcnRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnNpZ25hbD8uYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbmNlOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKHVwbG9hZGluZ0NvdW50UmVmLmN1cnJlbnQgPj0gbWF4Q29uY3VycmVudFVwbG9hZHMgJiYgdXBsb2FkaW5nQ291bnRSZWYuY3VycmVudCA+IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlKChyZXNvbHZlKT0+c2V0VGltZW91dChyZXNvbHZlLCAzMDApKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnRQcm9taXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5zaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVwbG9hZEFib3J0ZWRFcnJvcignRmlsZSB1cGxvYWQgYWJvcnRlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZGluZ0NvdW50UmVmLmN1cnJlbnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVJbmZvID0gYXdhaXQgdXBsb2FkRmlsZShwYXJhbXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWNrZXROYW1lOiBidWNrZXROYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwaVBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVJbmZvO1xuICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGxvYWRpbmdDb3VudFJlZi5jdXJyZW50LS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvbmZpcm1VcGxvYWQ6IGFzeW5jIChwYXJhbXMpPT57XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc3VjY2VzcyB9ID0gYXdhaXQgY29uZmlybVVwbG9hZChwYXJhbXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1Y2tldE5hbWU6IGJ1Y2tldE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcGlQYXRoXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFZGdlU3RvcmVDbGllbnRFcnJvcignRmFpbGVkIHRvIGNvbmZpcm0gdXBsb2FkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGRlbGV0ZTogYXN5bmMgKHBhcmFtcyk9PntcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzdWNjZXNzIH0gPSBhd2FpdCBkZWxldGVGaWxlKHBhcmFtcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVja2V0TmFtZTogYnVja2V0TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaVBhdGhcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVkZ2VTdG9yZUNsaWVudEVycm9yKCdGYWlsZWQgdG8gZGVsZXRlIGZpbGUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gYnVja2V0RnVuY3Rpb25zO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiB1cGxvYWRGaWxlKHsgZmlsZSwgc2lnbmFsLCBpbnB1dCwgb25Qcm9ncmVzc0NoYW5nZSwgb3B0aW9ucyB9LCB7IGFwaVBhdGgsIGJ1Y2tldE5hbWUgfSkge1xuICAgIHRyeSB7XG4gICAgICAgIG9uUHJvZ3Jlc3NDaGFuZ2U/LigwKTtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYCR7YXBpUGF0aH0vcmVxdWVzdC11cGxvYWRgLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsXG4gICAgICAgICAgICBzaWduYWw6IHNpZ25hbCxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBidWNrZXROYW1lLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGZpbGVJbmZvOiB7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbjogZmlsZS5uYW1lLnNwbGl0KCcuJykucG9wKCksXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGZpbGUudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogZmlsZS5zaXplLFxuICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZTogb3B0aW9ucz8ubWFudWFsRmlsZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VUYXJnZXRVcmw6IG9wdGlvbnM/LnJlcGxhY2VUYXJnZXRVcmwsXG4gICAgICAgICAgICAgICAgICAgIHRlbXBvcmFyeTogb3B0aW9ucz8udGVtcG9yYXJ5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZUVycm9yKHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgICAgIGlmICgnbXVsdGlwYXJ0JyBpbiBqc29uKSB7XG4gICAgICAgICAgICBhd2FpdCBtdWx0aXBhcnRVcGxvYWQoe1xuICAgICAgICAgICAgICAgIGJ1Y2tldE5hbWUsXG4gICAgICAgICAgICAgICAgbXVsdGlwYXJ0SW5mbzoganNvbi5tdWx0aXBhcnQsXG4gICAgICAgICAgICAgICAgb25Qcm9ncmVzc0NoYW5nZSxcbiAgICAgICAgICAgICAgICBzaWduYWwsXG4gICAgICAgICAgICAgICAgZmlsZSxcbiAgICAgICAgICAgICAgICBhcGlQYXRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICgndXBsb2FkVXJsJyBpbiBqc29uKSB7XG4gICAgICAgICAgICAvLyBTaW5nbGUgcGFydCB1cGxvYWRcbiAgICAgICAgICAgIC8vIFVwbG9hZCB0aGUgZmlsZSB0byB0aGUgc2lnbmVkIFVSTCBhbmQgZ2V0IHRoZSBwcm9ncmVzc1xuICAgICAgICAgICAgYXdhaXQgdXBsb2FkRmlsZUlubmVyKHtcbiAgICAgICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgICAgIHVwbG9hZFVybDoganNvbi51cGxvYWRVcmwsXG4gICAgICAgICAgICAgICAgb25Qcm9ncmVzc0NoYW5nZSxcbiAgICAgICAgICAgICAgICBzaWduYWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVkZ2VTdG9yZUNsaWVudEVycm9yKCdBbiBlcnJvciBvY2N1cnJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1cmw6IGdldFVybChqc29uLmFjY2Vzc1VybCwgYXBpUGF0aCksXG4gICAgICAgICAgICB0aHVtYm5haWxVcmw6IGpzb24udGh1bWJuYWlsVXJsID8gZ2V0VXJsKGpzb24udGh1bWJuYWlsVXJsLCBhcGlQYXRoKSA6IG51bGwsXG4gICAgICAgICAgICBzaXplOiBqc29uLnNpemUsXG4gICAgICAgICAgICB1cGxvYWRlZEF0OiBuZXcgRGF0ZShqc29uLnVwbG9hZGVkQXQpLFxuICAgICAgICAgICAgcGF0aDoganNvbi5wYXRoLFxuICAgICAgICAgICAgcGF0aE9yZGVyOiBqc29uLnBhdGhPcmRlcixcbiAgICAgICAgICAgIG1ldGFkYXRhOiBqc29uLm1ldGFkYXRhXG4gICAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVXBsb2FkQWJvcnRlZEVycm9yKCdGaWxlIHVwbG9hZCBhYm9ydGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgb25Qcm9ncmVzc0NoYW5nZT8uKDApO1xuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbn1cbi8qKlxuICogUHJvdGVjdGVkIGZpbGVzIG5lZWQgdGhpcmQtcGFydHkgY29va2llcyB0byB3b3JrLlxuICogU2luY2UgdGhpcmQgcGFydHkgY29va2llcyBkb24ndCB3b3JrIG9uIGxvY2FsaG9zdCxcbiAqIHdlIG5lZWQgdG8gcHJveHkgdGhlIGZpbGUgdGhyb3VnaCB0aGUgc2VydmVyLlxuICovIGZ1bmN0aW9uIGdldFVybCh1cmwsIGFwaVBhdGgpIHtcbiAgICBjb25zdCBtb2RlID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgOiBpbXBvcnQubWV0YS5lbnY/LkRFViA/ICdkZXZlbG9wbWVudCcgOiAncHJvZHVjdGlvbic7XG4gICAgaWYgKG1vZGUgPT09ICdkZXZlbG9wbWVudCcgJiYgIXVybC5pbmNsdWRlcygnL19wdWJsaWMvJykpIHtcbiAgICAgICAgY29uc3QgcHJveHlVcmwgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pO1xuICAgICAgICBwcm94eVVybC5wYXRobmFtZSA9IGAke2FwaVBhdGh9L3Byb3h5LWZpbGVgO1xuICAgICAgICBwcm94eVVybC5zZWFyY2ggPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgICAgIHVybFxuICAgICAgICB9KS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gcHJveHlVcmwudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbn1cbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZEZpbGVJbm5lcihwcm9wcykge1xuICAgIGNvbnN0IHsgZmlsZSwgdXBsb2FkVXJsLCBvblByb2dyZXNzQ2hhbmdlLCBzaWduYWwgfSA9IHByb3BzO1xuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KT0+e1xuICAgICAgICBpZiAoc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IFVwbG9hZEFib3J0ZWRFcnJvcignRmlsZSB1cGxvYWQgYWJvcnRlZCcpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHJlcXVlc3Qub3BlbignUFVUJywgdXBsb2FkVXJsKTtcbiAgICAgICAgLy8gVGhpcyBpcyBmb3IgQXp1cmUgcHJvdmlkZXIuIFNwZWNpZmllcyB0aGUgYmxvYiB0eXBlXG4gICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcigneC1tcy1ibG9iLXR5cGUnLCAnQmxvY2tCbG9iJyk7XG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignbG9hZHN0YXJ0JywgKCk9PntcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3NDaGFuZ2U/LigwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcXVlc3QudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgKGUpPT57XG4gICAgICAgICAgICBpZiAoZS5sZW5ndGhDb21wdXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgLy8gMiBkZWNpbWFsIHByb2dyZXNzXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBNYXRoLnJvdW5kKGUubG9hZGVkIC8gZS50b3RhbCAqIDEwMDAwKSAvIDEwMDtcbiAgICAgICAgICAgICAgICBvblByb2dyZXNzQ2hhbmdlPy4ocHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsICgpPT57XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdFcnJvciB1cGxvYWRpbmcgZmlsZScpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKT0+e1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBVcGxvYWRBYm9ydGVkRXJyb3IoJ0ZpbGUgdXBsb2FkIGFib3J0ZWQnKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlbmQnLCAoKT0+e1xuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBFVGFnIGhlYWRlciAobmVlZGVkIHRvIGNvbXBsZXRlIG11bHRpcGFydCB1cGxvYWQpXG4gICAgICAgICAgICByZXNvbHZlKHJlcXVlc3QuZ2V0UmVzcG9uc2VIZWFkZXIoJ0VUYWcnKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKT0+e1xuICAgICAgICAgICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3Quc2VuZChmaWxlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIG11bHRpcGFydFVwbG9hZChwYXJhbXMpIHtcbiAgICBjb25zdCB7IGJ1Y2tldE5hbWUsIG11bHRpcGFydEluZm8sIG9uUHJvZ3Jlc3NDaGFuZ2UsIGZpbGUsIHNpZ25hbCwgYXBpUGF0aCB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHsgcGFydFNpemUsIHBhcnRzLCB0b3RhbFBhcnRzLCB1cGxvYWRJZCwga2V5IH0gPSBtdWx0aXBhcnRJbmZvO1xuICAgIGNvbnN0IHVwbG9hZGluZ1BhcnRzID0gW107XG4gICAgY29uc3QgdXBsb2FkUGFydCA9IGFzeW5jIChwYXJhbXMpPT57XG4gICAgICAgIGNvbnN0IHsgcGFydCwgY2h1bmsgfSA9IHBhcmFtcztcbiAgICAgICAgY29uc3QgeyB1cGxvYWRVcmwgfSA9IHBhcnQ7XG4gICAgICAgIGNvbnN0IGVUYWcgPSBhd2FpdCB1cGxvYWRGaWxlSW5uZXIoe1xuICAgICAgICAgICAgZmlsZTogY2h1bmssXG4gICAgICAgICAgICB1cGxvYWRVcmwsXG4gICAgICAgICAgICBzaWduYWwsXG4gICAgICAgICAgICBvblByb2dyZXNzQ2hhbmdlOiAocHJvZ3Jlc3MpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgdXBsb2FkaW5nUGFydCA9IHVwbG9hZGluZ1BhcnRzLmZpbmQoKHApPT5wLnBhcnROdW1iZXIgPT09IHBhcnQucGFydE51bWJlcik7XG4gICAgICAgICAgICAgICAgaWYgKHVwbG9hZGluZ1BhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBsb2FkaW5nUGFydC5wcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVwbG9hZGluZ1BhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydE51bWJlcjogcGFydC5wYXJ0TnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHRvdGFsUHJvZ3Jlc3MgPSBNYXRoLnJvdW5kKHVwbG9hZGluZ1BhcnRzLnJlZHVjZSgoYWNjLCBwKT0+YWNjICsgcC5wcm9ncmVzcyAqIDEwMCwgMCkgLyB0b3RhbFBhcnRzKSAvIDEwMDtcbiAgICAgICAgICAgICAgICBvblByb2dyZXNzQ2hhbmdlPy4odG90YWxQcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWVUYWcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFZGdlU3RvcmVDbGllbnRFcnJvcignQ291bGQgbm90IGdldCBFVGFnIGZyb20gbXVsdGlwYXJ0IHJlc3BvbnNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhcnROdW1iZXI6IHBhcnQucGFydE51bWJlcixcbiAgICAgICAgICAgIGVUYWdcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8vIFVwbG9hZCB0aGUgcGFydHMgaW4gcGFyYWxsZWxcbiAgICBjb25zdCBjb21wbGV0ZWRQYXJ0cyA9IGF3YWl0IHF1ZXVlZFByb21pc2VzKHtcbiAgICAgICAgaXRlbXM6IHBhcnRzLm1hcCgocGFydCk9Pih7XG4gICAgICAgICAgICAgICAgcGFydCxcbiAgICAgICAgICAgICAgICBjaHVuazogZmlsZS5zbGljZSgocGFydC5wYXJ0TnVtYmVyIC0gMSkgKiBwYXJ0U2l6ZSwgcGFydC5wYXJ0TnVtYmVyICogcGFydFNpemUpXG4gICAgICAgICAgICB9KSksXG4gICAgICAgIGZuOiB1cGxvYWRQYXJ0LFxuICAgICAgICBtYXhQYXJhbGxlbDogNSxcbiAgICAgICAgbWF4UmV0cmllczogMTBcbiAgICB9KTtcbiAgICAvLyBDb21wbGV0ZSBtdWx0aXBhcnQgdXBsb2FkXG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYCR7YXBpUGF0aH0vY29tcGxldGUtbXVsdGlwYXJ0LXVwbG9hZGAsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIGJ1Y2tldE5hbWUsXG4gICAgICAgICAgICB1cGxvYWRJZCxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHBhcnRzOiBjb21wbGV0ZWRQYXJ0c1xuICAgICAgICB9KSxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgYXdhaXQgaGFuZGxlRXJyb3IocmVzKTtcbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBjb25maXJtVXBsb2FkKHsgdXJsIH0sIHsgYXBpUGF0aCwgYnVja2V0TmFtZSB9KSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYCR7YXBpUGF0aH0vY29uZmlybS11cGxvYWRgLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICBidWNrZXROYW1lXG4gICAgICAgIH0pLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICBhd2FpdCBoYW5kbGVFcnJvcihyZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLmpzb24oKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUZpbGUoeyB1cmwgfSwgeyBhcGlQYXRoLCBidWNrZXROYW1lIH0pIHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgJHthcGlQYXRofS9kZWxldGUtZmlsZWAsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIGJ1Y2tldE5hbWVcbiAgICAgICAgfSksXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVycm9yKHJlcyk7XG4gICAgfVxuICAgIHJldHVybiByZXMuanNvbigpO1xufVxuYXN5bmMgZnVuY3Rpb24gcXVldWVkUHJvbWlzZXMoeyBpdGVtcywgZm4sIG1heFBhcmFsbGVsLCBtYXhSZXRyaWVzID0gMCB9KSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IG5ldyBBcnJheShpdGVtcy5sZW5ndGgpO1xuICAgIGNvbnN0IGV4ZWN1dGVXaXRoUmV0cnkgPSBhc3luYyAoZnVuYywgcmV0cmllcyk9PntcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBmdW5jKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBVcGxvYWRBYm9ydGVkRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXRyaWVzID4gMCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKT0+c2V0VGltZW91dChyZXNvbHZlLCA1MDAwKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4ZWN1dGVXaXRoUmV0cnkoZnVuYywgcmV0cmllcyAtIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2VtYXBob3JlID0ge1xuICAgICAgICBjb3VudDogbWF4UGFyYWxsZWwsXG4gICAgICAgIGFzeW5jIHdhaXQgKCkge1xuICAgICAgICAgICAgLy8gSWYgd2UndmUgcmVhY2hlZCBvdXIgbWF4aW11bSBjb25jdXJyZW5jeSwgb3IgaXQncyB0aGUgbGFzdCBpdGVtLCB3YWl0XG4gICAgICAgICAgICB3aGlsZSh0aGlzLmNvdW50IDw9IDApYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpPT5zZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuICAgICAgICAgICAgdGhpcy5jb3VudC0tO1xuICAgICAgICB9LFxuICAgICAgICBzaWduYWwgKCkge1xuICAgICAgICAgICAgdGhpcy5jb3VudCsrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB0YXNrcyA9IGl0ZW1zLm1hcCgoaXRlbSwgaSk9Pihhc3luYyAoKT0+e1xuICAgICAgICAgICAgYXdhaXQgc2VtYXBob3JlLndhaXQoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZXhlY3V0ZVdpdGhSZXRyeSgoKT0+Zm4oaXRlbSksIG1heFJldHJpZXMpO1xuICAgICAgICAgICAgICAgIHJlc3VsdHNbaV0gPSByZXN1bHQ7XG4gICAgICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICAgICAgc2VtYXBob3JlLnNpZ25hbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpKTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbCh0YXNrcyk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG5cbmNvbnN0IERFRkFVTFRfQkFTRV9VUkwgPSAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnID8gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRURHRV9TVE9SRV9CQVNFX1VSTCA6IGltcG9ydC5tZXRhLmVudj8uRURHRV9TVE9SRV9CQVNFX1VSTCkgPz8gJ2h0dHBzOi8vZmlsZXMuZWRnZXN0b3JlLmRldic7XG5mdW5jdGlvbiBjcmVhdGVFZGdlU3RvcmVQcm92aWRlcihvcHRzKSB7XG4gICAgY29uc3QgRWRnZVN0b3JlQ29udGV4dCA9IC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xuICAgIGNvbnN0IEVkZ2VTdG9yZVByb3ZpZGVyID0gKHsgY2hpbGRyZW4sIGJhc2VQYXRoIH0pPT57XG4gICAgICAgIHJldHVybiBFZGdlU3RvcmVQcm92aWRlcklubmVyKHtcbiAgICAgICAgICAgIGNoaWxkcmVuLFxuICAgICAgICAgICAgY29udGV4dDogRWRnZVN0b3JlQ29udGV4dCxcbiAgICAgICAgICAgIGJhc2VQYXRoLFxuICAgICAgICAgICAgbWF4Q29uY3VycmVudFVwbG9hZHM6IG9wdHM/Lm1heENvbmN1cnJlbnRVcGxvYWRzXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgZnVuY3Rpb24gdXNlRWRnZVN0b3JlKCkge1xuICAgICAgICBpZiAoIUVkZ2VTdG9yZUNvbnRleHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVhY3QgQ29udGV4dCBpcyB1bmF2YWlsYWJsZSBpbiBTZXJ2ZXIgQ29tcG9uZW50cycpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBXZSBrbm93IHRoYXQgdGhlIGNvbnRleHQgdmFsdWUgc2hvdWxkIG5vdCBiZSB1bmRlZmluZWRcbiAgICAgICAgY29uc3QgdmFsdWUgPSBSZWFjdC51c2VDb250ZXh0KEVkZ2VTdG9yZUNvbnRleHQpO1xuICAgICAgICBpZiAoIXZhbHVlICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW2VkZ2VzdG9yZV06IGB1c2VFZGdlU3RvcmVgIG11c3QgYmUgd3JhcHBlZCBpbiBhIDxFZGdlU3RvcmVQcm92aWRlciAvPicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgRWRnZVN0b3JlUHJvdmlkZXIsXG4gICAgICAgIHVzZUVkZ2VTdG9yZVxuICAgIH07XG59XG5mdW5jdGlvbiBFZGdlU3RvcmVQcm92aWRlcklubmVyKHsgY2hpbGRyZW4sIGNvbnRleHQsIGJhc2VQYXRoLCBtYXhDb25jdXJyZW50VXBsb2FkcyB9KSB7XG4gICAgY29uc3QgYXBpUGF0aCA9IGJhc2VQYXRoID8gYCR7YmFzZVBhdGh9YCA6ICcvYXBpL2VkZ2VzdG9yZSc7XG4gICAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgICAgIGxvYWRpbmc6IHRydWUsXG4gICAgICAgIGluaXRpYWxpemVkOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGZhbHNlXG4gICAgfSk7XG4gICAgY29uc3QgdXBsb2FkaW5nQ291bnRSZWYgPSBSZWFjdC51c2VSZWYoMCk7XG4gICAgY29uc3QgaW5pdEV4ZWN1dGVkID0gUmVhY3QudXNlUmVmKGZhbHNlKTsgLy8gdG8gbWFrZSBzdXJlIHdlIGRvbid0IHJ1biBpbml0IHR3aWNlXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpPT57XG4gICAgICAgIGlmICghaW5pdEV4ZWN1dGVkLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHZvaWQgaW5pdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgaW5pdEV4ZWN1dGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB9LCBbXSk7XG4gICAgYXN5bmMgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBsb2FkaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIGluaXRpYWxpemVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYCR7YXBpUGF0aH0vaW5pdGAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyZXMub2spIHtcbiAgICAgICAgICAgICAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbm5lclJlcyA9IGF3YWl0IGZldGNoKGAke0RFRkFVTFRfQkFTRV9VUkx9L19pbml0YCwge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAneC1lZGdlc3RvcmUtdG9rZW4nOiBqc29uLnRva2VuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXJSZXMub2spIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbGl6ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsaXplZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVkZ2VTdG9yZUNsaWVudEVycm9yKFwiQ291bGRuJ3QgaW5pdGlhbGl6ZSBFZGdlIFN0b3JlLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxpemVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhd2FpdCBoYW5kbGVFcnJvcihyZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBsb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpbml0aWFsaXplZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3I6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICBhd2FpdCBpbml0KCk7XG4gICAgfVxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi8gUmVhY3QuY3JlYXRlRWxlbWVudChjb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICBlZGdlc3RvcmU6IGNyZWF0ZU5leHRQcm94eSh7XG4gICAgICAgICAgICAgICAgYXBpUGF0aCxcbiAgICAgICAgICAgICAgICB1cGxvYWRpbmdDb3VudFJlZixcbiAgICAgICAgICAgICAgICBtYXhDb25jdXJyZW50VXBsb2Fkc1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICByZXNldCxcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgIH1cbiAgICB9LCBjaGlsZHJlbikpO1xufVxuXG5leHBvcnQgeyBjcmVhdGVFZGdlU3RvcmVQcm92aWRlciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@edgestore/react/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@edgestore/react/dist/uploadAbortedError-e1379bb0.mjs":
/*!****************************************************************************!*\
  !*** ./node_modules/@edgestore/react/dist/uploadAbortedError-e1379bb0.mjs ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   U: () => (/* binding */ UploadAbortedError)\n/* harmony export */ });\nclass UploadAbortedError extends Error {\n    constructor(message){\n        super(message);\n        this.name = 'UploadAbortedError';\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGVkZ2VzdG9yZS9yZWFjdC9kaXN0L3VwbG9hZEFib3J0ZWRFcnJvci1lMTM3OWJiMC5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3Rpb24tY2xvbmUvLi9ub2RlX21vZHVsZXMvQGVkZ2VzdG9yZS9yZWFjdC9kaXN0L3VwbG9hZEFib3J0ZWRFcnJvci1lMTM3OWJiMC5tanM/YTQ1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBVcGxvYWRBYm9ydGVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSl7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnVXBsb2FkQWJvcnRlZEVycm9yJztcbiAgICB9XG59XG5cbmV4cG9ydCB7IFVwbG9hZEFib3J0ZWRFcnJvciBhcyBVIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@edgestore/react/dist/uploadAbortedError-e1379bb0.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@edgestore/react/dist/utils/index.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@edgestore/react/dist/utils/index.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   formatFileSize: () => (/* binding */ formatFileSize),\n/* harmony export */   getDownloadUrl: () => (/* binding */ getDownloadUrl)\n/* harmony export */ });\n/**\n * This will add the necessary query param to the url\n * to make the browser download the file instead of opening it.\n *\n * You can also override the name of the file by passing the name param.\n */ function getDownloadUrl(url, name) {\n    const urlObj = new URL(url);\n    urlObj.searchParams.set('download', name ?? 'true');\n    return urlObj.toString();\n}\n/**\n * This will format the file size to a human-readable format.\n *\n * @example 1024 => 1 KB\n */ function formatFileSize(bytes) {\n    if (!bytes) return '0 B';\n    const k = 1024;\n    const dm = 2;\n    const sizes = [\n        'B',\n        'KB',\n        'MB',\n        'GB',\n        'TB',\n        'PB',\n        'EB',\n        'ZB',\n        'YB'\n    ];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGVkZ2VzdG9yZS9yZWFjdC9kaXN0L3V0aWxzL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0RBQWtELEVBQUUsU0FBUztBQUMzRTs7QUFFMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3Rpb24tY2xvbmUvLi9ub2RlX21vZHVsZXMvQGVkZ2VzdG9yZS9yZWFjdC9kaXN0L3V0aWxzL2luZGV4Lm1qcz9lNGUzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhpcyB3aWxsIGFkZCB0aGUgbmVjZXNzYXJ5IHF1ZXJ5IHBhcmFtIHRvIHRoZSB1cmxcbiAqIHRvIG1ha2UgdGhlIGJyb3dzZXIgZG93bmxvYWQgdGhlIGZpbGUgaW5zdGVhZCBvZiBvcGVuaW5nIGl0LlxuICpcbiAqIFlvdSBjYW4gYWxzbyBvdmVycmlkZSB0aGUgbmFtZSBvZiB0aGUgZmlsZSBieSBwYXNzaW5nIHRoZSBuYW1lIHBhcmFtLlxuICovIGZ1bmN0aW9uIGdldERvd25sb2FkVXJsKHVybCwgbmFtZSkge1xuICAgIGNvbnN0IHVybE9iaiA9IG5ldyBVUkwodXJsKTtcbiAgICB1cmxPYmouc2VhcmNoUGFyYW1zLnNldCgnZG93bmxvYWQnLCBuYW1lID8/ICd0cnVlJyk7XG4gICAgcmV0dXJuIHVybE9iai50b1N0cmluZygpO1xufVxuLyoqXG4gKiBUaGlzIHdpbGwgZm9ybWF0IHRoZSBmaWxlIHNpemUgdG8gYSBodW1hbi1yZWFkYWJsZSBmb3JtYXQuXG4gKlxuICogQGV4YW1wbGUgMTAyNCA9PiAxIEtCXG4gKi8gZnVuY3Rpb24gZm9ybWF0RmlsZVNpemUoYnl0ZXMpIHtcbiAgICBpZiAoIWJ5dGVzKSByZXR1cm4gJzAgQic7XG4gICAgY29uc3QgayA9IDEwMjQ7XG4gICAgY29uc3QgZG0gPSAyO1xuICAgIGNvbnN0IHNpemVzID0gW1xuICAgICAgICAnQicsXG4gICAgICAgICdLQicsXG4gICAgICAgICdNQicsXG4gICAgICAgICdHQicsXG4gICAgICAgICdUQicsXG4gICAgICAgICdQQicsXG4gICAgICAgICdFQicsXG4gICAgICAgICdaQicsXG4gICAgICAgICdZQidcbiAgICBdO1xuICAgIGNvbnN0IGkgPSBNYXRoLmZsb29yKE1hdGgubG9nKGJ5dGVzKSAvIE1hdGgubG9nKGspKTtcbiAgICByZXR1cm4gYCR7cGFyc2VGbG9hdCgoYnl0ZXMgLyBNYXRoLnBvdyhrLCBpKSkudG9GaXhlZChkbSkpfSAke3NpemVzW2ldfWA7XG59XG5cbmV4cG9ydCB7IGZvcm1hdEZpbGVTaXplLCBnZXREb3dubG9hZFVybCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@edgestore/react/dist/utils/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@edgestore/shared/dist/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/@edgestore/shared/dist/index.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EDGE_STORE_ERROR_CODES: () => (/* binding */ EDGE_STORE_ERROR_CODES),\n/* harmony export */   EdgeStoreApiClientError: () => (/* binding */ EdgeStoreApiClientError),\n/* harmony export */   EdgeStoreError: () => (/* binding */ EdgeStoreError),\n/* harmony export */   initEdgeStore: () => (/* binding */ initEdgeStore)\n/* harmony export */ });\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zod */ \"(ssr)/./node_modules/zod/lib/index.mjs\");\n\n\nfunction _define_property$1(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\n/* eslint-disable @typescript-eslint/no-non-null-assertion */ const EDGE_STORE_ERROR_CODES = {\n    BAD_REQUEST: 400,\n    FILE_TOO_LARGE: 400,\n    MIME_TYPE_NOT_ALLOWED: 400,\n    UNAUTHORIZED: 401,\n    UPLOAD_NOT_ALLOWED: 403,\n    DELETE_NOT_ALLOWED: 403,\n    CREATE_CONTEXT_ERROR: 500,\n    SERVER_ERROR: 500\n};\nclass EdgeStoreError extends Error {\n    formattedMessage() {\n        return `${this.message}${this.details ? `\\n    Details: ${JSON.stringify(this.details)}` : ''}${this.cause ? `\\n    Caused by: ${this.cause.message}` : ''}`;\n    }\n    formattedJson() {\n        return {\n            message: this.code === 'SERVER_ERROR' ? 'Internal server error' : this.message,\n            code: this.code,\n            details: this.details\n        };\n    }\n    constructor(opts){\n        super(opts.message);\n        _define_property$1(this, \"cause\", void 0);\n        _define_property$1(this, \"code\", void 0);\n        _define_property$1(this, \"level\", void 0);\n        _define_property$1(this, \"details\", void 0);\n        this.name = 'EdgeStoreError';\n        this.code = opts.code;\n        this.cause = opts.cause;\n        this.level = EDGE_STORE_ERROR_CODES[opts.code] >= 500 ? 'error' : 'warn';\n        this.details = 'details' in opts ? opts.details : undefined;\n    }\n}\n\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nclass EdgeStoreApiClientError extends Error {\n    constructor(opts){\n        super(opts.response.message);\n        _define_property(this, \"data\", void 0);\n        this.name = 'EdgeStoreApiClientError';\n        this.data = opts.response;\n    }\n}\n\n/**\n * Creates a Proxy that prints the path to the property when called.\n *\n * Example:\n *\n * ```ts\n * const pathParamProxy = createPathParamProxy();\n * console.log(pathParamProxy.ctx.user.id());\n * // Logs: \"ctx.user.id\"\n * console.log(pathParamProxy.input.type());\n * // Logs: \"input.type\"\n * ```\n */ function createPathParamProxy() {\n    const getPath = (target, _prop)=>{\n        const proxyFunction = ()=>target;\n        return new Proxy(proxyFunction, {\n            get: (_target, propChild)=>{\n                return getPath(`${target}.${String(propChild)}`);\n            }\n        });\n    };\n    return new Proxy(()=>'', {\n        get: (_target, prop)=>{\n            return getPath(String(prop));\n        }\n    });\n}\n\nconst createNewBuilder = (initDef, newDef)=>{\n    const mergedDef = {\n        ...initDef,\n        ...newDef\n    };\n    return createBuilder({\n        type: mergedDef.type\n    }, mergedDef);\n};\nfunction createBuilder(opts, initDef) {\n    const _def = {\n        type: opts.type,\n        input: zod__WEBPACK_IMPORTED_MODULE_0__.z.never(),\n        path: [],\n        metadata: ()=>({}),\n        ...initDef\n    };\n    return {\n        $config: {\n            ctx: undefined\n        },\n        // @ts-expect-error - I think it would be too much work to make this type correct.\n        _def,\n        input (input) {\n            return createNewBuilder(_def, {\n                input\n            });\n        },\n        path (pathResolver) {\n            // TODO: Should throw a runtime error in the following cases:\n            // 1. in case of multiple keys in one object\n            // 2. in case of duplicate keys\n            const pathParamProxy = createPathParamProxy();\n            const params = pathResolver(pathParamProxy);\n            return createNewBuilder(_def, {\n                path: params\n            });\n        },\n        metadata (metadata) {\n            return createNewBuilder(_def, {\n                metadata\n            });\n        },\n        accessControl (accessControl) {\n            return createNewBuilder(_def, {\n                accessControl: accessControl\n            });\n        },\n        beforeUpload (beforeUpload) {\n            return createNewBuilder(_def, {\n                beforeUpload\n            });\n        },\n        beforeDelete (beforeDelete) {\n            return createNewBuilder(_def, {\n                beforeDelete\n            });\n        }\n    };\n}\nclass EdgeStoreBuilder {\n    context() {\n        return new EdgeStoreBuilder();\n    }\n    create() {\n        return createEdgeStoreInner()();\n    }\n}\nfunction createRouterFactory() {\n    return function createRouterInner(buckets) {\n        return {\n            $config: {\n                ctx: undefined\n            },\n            buckets\n        };\n    };\n}\nfunction initBucket(type, config) {\n    return createBuilder({\n        type\n    }, {\n        bucketConfig: config\n    });\n}\nfunction createEdgeStoreInner() {\n    return function initEdgeStoreInner() {\n        return {\n            /**\n       * Builder object for creating an image bucket\n       */ imageBucket (config) {\n                return initBucket('IMAGE', config);\n            },\n            /**\n       * Builder object for creating a file bucket\n       */ fileBucket (config) {\n                return initBucket('FILE', config);\n            },\n            /**\n       * Create a router\n       */ router: createRouterFactory()\n        };\n    };\n}\n/**\n * Initialize EdgeStore - be done exactly once per backend\n */ const initEdgeStore = new EdgeStoreBuilder(); // ↓↓↓ TYPE TESTS ↓↓↓\n // type Context = {\n //   userId: string;\n //   userRole: 'admin' | 'visitor';\n // };\n // const es = initEdgeStore.context<Context>().create();\n // const imagesBucket = es.imageBucket()\n //   .input(\n //     z.object({\n //       type: z.enum(['profile', 'post']),\n //       extension: z.string().optional(),\n //     }),\n //   )\n //   .path(({ ctx, input }) => [{ author: ctx.userId }, { type: input.type }])\n //   .metadata(({ ctx, input }) => ({\n //     extension: input.extension,\n //     role: ctx.userRole,\n //   }))\n //   .beforeUpload(() => {\n //     return true;\n //   });\n // const a = es.imageBucket()\n //   .input(z.object({ type: z.string(), someMeta: z.string().optional() }))\n //   .path(({ ctx, input }) => [{ author: ctx.userId }, { type: input.type }])\n //   .metadata(({ ctx, input }) => ({\n //     role: ctx.userRole,\n //     someMeta: input.someMeta,\n //   }))\n //   .accessControl({\n //     OR: [\n //       {\n //         userId: { path: 'author' }, // this will check if the userId is the same as the author in the path parameter\n //       },\n //       {\n //         userRole: 'admin', // this is the same as { userRole: { eq: \"admin\" } }\n //       },\n //     ],\n //   })\n //   .beforeUpload(({ ctx, input }) => {\n //     return true;\n //   })\n //   .beforeDelete(({ ctx, file }) => {\n //     return true;\n //   });\n // const b = es.imageBucket().path(({ ctx }) => [{ author: ctx.userId }]);\n // const router = es.router({\n //   original: imagesBucket,\n //   imageBucket: a,\n //   imageBucket2: b,\n // });\n // export { router };\n // type ListFilesResponse<TBucket extends AnyRouter['buckets'][string]> = {\n //   data: {\n //     // url: string;\n //     // size: number;\n //     // uploadedAt: Date;\n //     // metadata: InferMetadataObject<TBucket>;\n //     path: InferBucketPathKeys<TBucket> extends string ? {\n //       [key: string]: string;\n //     } :{\n //       [TKey in InferBucketPathKeys<TBucket>]: string;\n //     };\n //   }[];\n //   pagination: {\n //     currentPage: number;\n //     totalPages: number;\n //     totalCount: number;\n //   };\n // };\n // type TPathKeys = 'author' | 'type';\n // type TPathKeys2 = InferBucketPathKeys<AnyBuilder>;\n // type ObjectWithKeys<TKeys extends string> = {\n //   [TKey in TKeys]: string;\n // };\n // type Test1 = ObjectWithKeys<TPathKeys>;\n // type Test2 = ObjectWithKeys<TPathKeys2>;\n // type PathKeys = InferBucketPathKeys<typeof router.buckets.imageBucket>;\n // type MetadataKeys = InferMetadataObject<typeof router.buckets.imageBucket>;\n // type MyEdgeStoreRouter = typeof router;\n // type MyAccessControl = AccessControlSchema<Context, AnyDef>;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGVkZ2VzdG9yZS9zaGFyZWQvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixhQUFhLEVBQUUsaUNBQWlDLDZCQUE2QixPQUFPLEVBQUUsaUNBQWlDLG1CQUFtQixPQUFPO0FBQ25LO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTyxHQUFHLGtCQUFrQjtBQUM5RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQ0FBQztBQUNoQjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxlQUFlLFlBQVksUUFBUSxvQkFBb0IsSUFBSSxrQkFBa0I7QUFDN0UsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esd0JBQXdCLG1EQUFtRDtBQUMzRSxlQUFlLFlBQVksUUFBUSxvQkFBb0IsSUFBSSxrQkFBa0I7QUFDN0UsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDLFdBQVc7QUFDWDtBQUNBLHdEQUF3RCxZQUFZO0FBQ3BFLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUCx1QkFBdUIsWUFBWTtBQUNuQztBQUNBLE9BQU87QUFDUCx1QkFBdUIsV0FBVztBQUNsQztBQUNBLE9BQU87QUFDUCx1Q0FBdUMsS0FBSyxRQUFRLG9CQUFvQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTBGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbm90aW9uLWNsb25lLy4vbm9kZV9tb2R1bGVzL0BlZGdlc3RvcmUvc2hhcmVkL2Rpc3QvaW5kZXgubWpzPzExZmUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgeiB9IGZyb20gJ3pvZCc7XG5cbmZ1bmN0aW9uIF9kZWZpbmVfcHJvcGVydHkkMShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvbiAqLyBjb25zdCBFREdFX1NUT1JFX0VSUk9SX0NPREVTID0ge1xuICAgIEJBRF9SRVFVRVNUOiA0MDAsXG4gICAgRklMRV9UT09fTEFSR0U6IDQwMCxcbiAgICBNSU1FX1RZUEVfTk9UX0FMTE9XRUQ6IDQwMCxcbiAgICBVTkFVVEhPUklaRUQ6IDQwMSxcbiAgICBVUExPQURfTk9UX0FMTE9XRUQ6IDQwMyxcbiAgICBERUxFVEVfTk9UX0FMTE9XRUQ6IDQwMyxcbiAgICBDUkVBVEVfQ09OVEVYVF9FUlJPUjogNTAwLFxuICAgIFNFUlZFUl9FUlJPUjogNTAwXG59O1xuY2xhc3MgRWRnZVN0b3JlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgZm9ybWF0dGVkTWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMubWVzc2FnZX0ke3RoaXMuZGV0YWlscyA/IGBcXG4gICAgRGV0YWlsczogJHtKU09OLnN0cmluZ2lmeSh0aGlzLmRldGFpbHMpfWAgOiAnJ30ke3RoaXMuY2F1c2UgPyBgXFxuICAgIENhdXNlZCBieTogJHt0aGlzLmNhdXNlLm1lc3NhZ2V9YCA6ICcnfWA7XG4gICAgfVxuICAgIGZvcm1hdHRlZEpzb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlOiB0aGlzLmNvZGUgPT09ICdTRVJWRVJfRVJST1InID8gJ0ludGVybmFsIHNlcnZlciBlcnJvcicgOiB0aGlzLm1lc3NhZ2UsXG4gICAgICAgICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICAgICAgICBkZXRhaWxzOiB0aGlzLmRldGFpbHNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iob3B0cyl7XG4gICAgICAgIHN1cGVyKG9wdHMubWVzc2FnZSk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkkMSh0aGlzLCBcImNhdXNlXCIsIHZvaWQgMCk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkkMSh0aGlzLCBcImNvZGVcIiwgdm9pZCAwKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSQxKHRoaXMsIFwibGV2ZWxcIiwgdm9pZCAwKTtcbiAgICAgICAgX2RlZmluZV9wcm9wZXJ0eSQxKHRoaXMsIFwiZGV0YWlsc1wiLCB2b2lkIDApO1xuICAgICAgICB0aGlzLm5hbWUgPSAnRWRnZVN0b3JlRXJyb3InO1xuICAgICAgICB0aGlzLmNvZGUgPSBvcHRzLmNvZGU7XG4gICAgICAgIHRoaXMuY2F1c2UgPSBvcHRzLmNhdXNlO1xuICAgICAgICB0aGlzLmxldmVsID0gRURHRV9TVE9SRV9FUlJPUl9DT0RFU1tvcHRzLmNvZGVdID49IDUwMCA/ICdlcnJvcicgOiAnd2Fybic7XG4gICAgICAgIHRoaXMuZGV0YWlscyA9ICdkZXRhaWxzJyBpbiBvcHRzID8gb3B0cy5kZXRhaWxzIDogdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZV9wcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBpZiAoa2V5IGluIG9iaikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuY2xhc3MgRWRnZVN0b3JlQXBpQ2xpZW50RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3Iob3B0cyl7XG4gICAgICAgIHN1cGVyKG9wdHMucmVzcG9uc2UubWVzc2FnZSk7XG4gICAgICAgIF9kZWZpbmVfcHJvcGVydHkodGhpcywgXCJkYXRhXCIsIHZvaWQgMCk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdFZGdlU3RvcmVBcGlDbGllbnRFcnJvcic7XG4gICAgICAgIHRoaXMuZGF0YSA9IG9wdHMucmVzcG9uc2U7XG4gICAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBQcm94eSB0aGF0IHByaW50cyB0aGUgcGF0aCB0byB0aGUgcHJvcGVydHkgd2hlbiBjYWxsZWQuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGB0c1xuICogY29uc3QgcGF0aFBhcmFtUHJveHkgPSBjcmVhdGVQYXRoUGFyYW1Qcm94eSgpO1xuICogY29uc29sZS5sb2cocGF0aFBhcmFtUHJveHkuY3R4LnVzZXIuaWQoKSk7XG4gKiAvLyBMb2dzOiBcImN0eC51c2VyLmlkXCJcbiAqIGNvbnNvbGUubG9nKHBhdGhQYXJhbVByb3h5LmlucHV0LnR5cGUoKSk7XG4gKiAvLyBMb2dzOiBcImlucHV0LnR5cGVcIlxuICogYGBgXG4gKi8gZnVuY3Rpb24gY3JlYXRlUGF0aFBhcmFtUHJveHkoKSB7XG4gICAgY29uc3QgZ2V0UGF0aCA9ICh0YXJnZXQsIF9wcm9wKT0+e1xuICAgICAgICBjb25zdCBwcm94eUZ1bmN0aW9uID0gKCk9PnRhcmdldDtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eShwcm94eUZ1bmN0aW9uLCB7XG4gICAgICAgICAgICBnZXQ6IChfdGFyZ2V0LCBwcm9wQ2hpbGQpPT57XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFBhdGgoYCR7dGFyZ2V0fS4ke1N0cmluZyhwcm9wQ2hpbGQpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBuZXcgUHJveHkoKCk9PicnLCB7XG4gICAgICAgIGdldDogKF90YXJnZXQsIHByb3ApPT57XG4gICAgICAgICAgICByZXR1cm4gZ2V0UGF0aChTdHJpbmcocHJvcCkpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmNvbnN0IGNyZWF0ZU5ld0J1aWxkZXIgPSAoaW5pdERlZiwgbmV3RGVmKT0+e1xuICAgIGNvbnN0IG1lcmdlZERlZiA9IHtcbiAgICAgICAgLi4uaW5pdERlZixcbiAgICAgICAgLi4ubmV3RGVmXG4gICAgfTtcbiAgICByZXR1cm4gY3JlYXRlQnVpbGRlcih7XG4gICAgICAgIHR5cGU6IG1lcmdlZERlZi50eXBlXG4gICAgfSwgbWVyZ2VkRGVmKTtcbn07XG5mdW5jdGlvbiBjcmVhdGVCdWlsZGVyKG9wdHMsIGluaXREZWYpIHtcbiAgICBjb25zdCBfZGVmID0ge1xuICAgICAgICB0eXBlOiBvcHRzLnR5cGUsXG4gICAgICAgIGlucHV0OiB6Lm5ldmVyKCksXG4gICAgICAgIHBhdGg6IFtdLFxuICAgICAgICBtZXRhZGF0YTogKCk9Pih7fSksXG4gICAgICAgIC4uLmluaXREZWZcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgICRjb25maWc6IHtcbiAgICAgICAgICAgIGN0eDogdW5kZWZpbmVkXG4gICAgICAgIH0sXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBJIHRoaW5rIGl0IHdvdWxkIGJlIHRvbyBtdWNoIHdvcmsgdG8gbWFrZSB0aGlzIHR5cGUgY29ycmVjdC5cbiAgICAgICAgX2RlZixcbiAgICAgICAgaW5wdXQgKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTmV3QnVpbGRlcihfZGVmLCB7XG4gICAgICAgICAgICAgICAgaW5wdXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBwYXRoIChwYXRoUmVzb2x2ZXIpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFNob3VsZCB0aHJvdyBhIHJ1bnRpbWUgZXJyb3IgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcbiAgICAgICAgICAgIC8vIDEuIGluIGNhc2Ugb2YgbXVsdGlwbGUga2V5cyBpbiBvbmUgb2JqZWN0XG4gICAgICAgICAgICAvLyAyLiBpbiBjYXNlIG9mIGR1cGxpY2F0ZSBrZXlzXG4gICAgICAgICAgICBjb25zdCBwYXRoUGFyYW1Qcm94eSA9IGNyZWF0ZVBhdGhQYXJhbVByb3h5KCk7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBwYXRoUmVzb2x2ZXIocGF0aFBhcmFtUHJveHkpO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZU5ld0J1aWxkZXIoX2RlZiwge1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhcmFtc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG1ldGFkYXRhIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZU5ld0J1aWxkZXIoX2RlZiwge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgYWNjZXNzQ29udHJvbCAoYWNjZXNzQ29udHJvbCkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZU5ld0J1aWxkZXIoX2RlZiwge1xuICAgICAgICAgICAgICAgIGFjY2Vzc0NvbnRyb2w6IGFjY2Vzc0NvbnRyb2xcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBiZWZvcmVVcGxvYWQgKGJlZm9yZVVwbG9hZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZU5ld0J1aWxkZXIoX2RlZiwge1xuICAgICAgICAgICAgICAgIGJlZm9yZVVwbG9hZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGJlZm9yZURlbGV0ZSAoYmVmb3JlRGVsZXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTmV3QnVpbGRlcihfZGVmLCB7XG4gICAgICAgICAgICAgICAgYmVmb3JlRGVsZXRlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5jbGFzcyBFZGdlU3RvcmVCdWlsZGVyIHtcbiAgICBjb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gbmV3IEVkZ2VTdG9yZUJ1aWxkZXIoKTtcbiAgICB9XG4gICAgY3JlYXRlKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRWRnZVN0b3JlSW5uZXIoKSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlckZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVJvdXRlcklubmVyKGJ1Y2tldHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICRjb25maWc6IHtcbiAgICAgICAgICAgICAgICBjdHg6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJ1Y2tldHNcbiAgICAgICAgfTtcbiAgICB9O1xufVxuZnVuY3Rpb24gaW5pdEJ1Y2tldCh0eXBlLCBjb25maWcpIHtcbiAgICByZXR1cm4gY3JlYXRlQnVpbGRlcih7XG4gICAgICAgIHR5cGVcbiAgICB9LCB7XG4gICAgICAgIGJ1Y2tldENvbmZpZzogY29uZmlnXG4gICAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVFZGdlU3RvcmVJbm5lcigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaW5pdEVkZ2VTdG9yZUlubmVyKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgKiBCdWlsZGVyIG9iamVjdCBmb3IgY3JlYXRpbmcgYW4gaW1hZ2UgYnVja2V0XG4gICAgICAgKi8gaW1hZ2VCdWNrZXQgKGNvbmZpZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbml0QnVja2V0KCdJTUFHRScsIGNvbmZpZyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgKiBCdWlsZGVyIG9iamVjdCBmb3IgY3JlYXRpbmcgYSBmaWxlIGJ1Y2tldFxuICAgICAgICovIGZpbGVCdWNrZXQgKGNvbmZpZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbml0QnVja2V0KCdGSUxFJywgY29uZmlnKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAqIENyZWF0ZSBhIHJvdXRlclxuICAgICAgICovIHJvdXRlcjogY3JlYXRlUm91dGVyRmFjdG9yeSgpXG4gICAgICAgIH07XG4gICAgfTtcbn1cbi8qKlxuICogSW5pdGlhbGl6ZSBFZGdlU3RvcmUgLSBiZSBkb25lIGV4YWN0bHkgb25jZSBwZXIgYmFja2VuZFxuICovIGNvbnN0IGluaXRFZGdlU3RvcmUgPSBuZXcgRWRnZVN0b3JlQnVpbGRlcigpOyAvLyDihpPihpPihpMgVFlQRSBURVNUUyDihpPihpPihpNcbiAvLyB0eXBlIENvbnRleHQgPSB7XG4gLy8gICB1c2VySWQ6IHN0cmluZztcbiAvLyAgIHVzZXJSb2xlOiAnYWRtaW4nIHwgJ3Zpc2l0b3InO1xuIC8vIH07XG4gLy8gY29uc3QgZXMgPSBpbml0RWRnZVN0b3JlLmNvbnRleHQ8Q29udGV4dD4oKS5jcmVhdGUoKTtcbiAvLyBjb25zdCBpbWFnZXNCdWNrZXQgPSBlcy5pbWFnZUJ1Y2tldCgpXG4gLy8gICAuaW5wdXQoXG4gLy8gICAgIHoub2JqZWN0KHtcbiAvLyAgICAgICB0eXBlOiB6LmVudW0oWydwcm9maWxlJywgJ3Bvc3QnXSksXG4gLy8gICAgICAgZXh0ZW5zaW9uOiB6LnN0cmluZygpLm9wdGlvbmFsKCksXG4gLy8gICAgIH0pLFxuIC8vICAgKVxuIC8vICAgLnBhdGgoKHsgY3R4LCBpbnB1dCB9KSA9PiBbeyBhdXRob3I6IGN0eC51c2VySWQgfSwgeyB0eXBlOiBpbnB1dC50eXBlIH1dKVxuIC8vICAgLm1ldGFkYXRhKCh7IGN0eCwgaW5wdXQgfSkgPT4gKHtcbiAvLyAgICAgZXh0ZW5zaW9uOiBpbnB1dC5leHRlbnNpb24sXG4gLy8gICAgIHJvbGU6IGN0eC51c2VyUm9sZSxcbiAvLyAgIH0pKVxuIC8vICAgLmJlZm9yZVVwbG9hZCgoKSA9PiB7XG4gLy8gICAgIHJldHVybiB0cnVlO1xuIC8vICAgfSk7XG4gLy8gY29uc3QgYSA9IGVzLmltYWdlQnVja2V0KClcbiAvLyAgIC5pbnB1dCh6Lm9iamVjdCh7IHR5cGU6IHouc3RyaW5nKCksIHNvbWVNZXRhOiB6LnN0cmluZygpLm9wdGlvbmFsKCkgfSkpXG4gLy8gICAucGF0aCgoeyBjdHgsIGlucHV0IH0pID0+IFt7IGF1dGhvcjogY3R4LnVzZXJJZCB9LCB7IHR5cGU6IGlucHV0LnR5cGUgfV0pXG4gLy8gICAubWV0YWRhdGEoKHsgY3R4LCBpbnB1dCB9KSA9PiAoe1xuIC8vICAgICByb2xlOiBjdHgudXNlclJvbGUsXG4gLy8gICAgIHNvbWVNZXRhOiBpbnB1dC5zb21lTWV0YSxcbiAvLyAgIH0pKVxuIC8vICAgLmFjY2Vzc0NvbnRyb2woe1xuIC8vICAgICBPUjogW1xuIC8vICAgICAgIHtcbiAvLyAgICAgICAgIHVzZXJJZDogeyBwYXRoOiAnYXV0aG9yJyB9LCAvLyB0aGlzIHdpbGwgY2hlY2sgaWYgdGhlIHVzZXJJZCBpcyB0aGUgc2FtZSBhcyB0aGUgYXV0aG9yIGluIHRoZSBwYXRoIHBhcmFtZXRlclxuIC8vICAgICAgIH0sXG4gLy8gICAgICAge1xuIC8vICAgICAgICAgdXNlclJvbGU6ICdhZG1pbicsIC8vIHRoaXMgaXMgdGhlIHNhbWUgYXMgeyB1c2VyUm9sZTogeyBlcTogXCJhZG1pblwiIH0gfVxuIC8vICAgICAgIH0sXG4gLy8gICAgIF0sXG4gLy8gICB9KVxuIC8vICAgLmJlZm9yZVVwbG9hZCgoeyBjdHgsIGlucHV0IH0pID0+IHtcbiAvLyAgICAgcmV0dXJuIHRydWU7XG4gLy8gICB9KVxuIC8vICAgLmJlZm9yZURlbGV0ZSgoeyBjdHgsIGZpbGUgfSkgPT4ge1xuIC8vICAgICByZXR1cm4gdHJ1ZTtcbiAvLyAgIH0pO1xuIC8vIGNvbnN0IGIgPSBlcy5pbWFnZUJ1Y2tldCgpLnBhdGgoKHsgY3R4IH0pID0+IFt7IGF1dGhvcjogY3R4LnVzZXJJZCB9XSk7XG4gLy8gY29uc3Qgcm91dGVyID0gZXMucm91dGVyKHtcbiAvLyAgIG9yaWdpbmFsOiBpbWFnZXNCdWNrZXQsXG4gLy8gICBpbWFnZUJ1Y2tldDogYSxcbiAvLyAgIGltYWdlQnVja2V0MjogYixcbiAvLyB9KTtcbiAvLyBleHBvcnQgeyByb3V0ZXIgfTtcbiAvLyB0eXBlIExpc3RGaWxlc1Jlc3BvbnNlPFRCdWNrZXQgZXh0ZW5kcyBBbnlSb3V0ZXJbJ2J1Y2tldHMnXVtzdHJpbmddPiA9IHtcbiAvLyAgIGRhdGE6IHtcbiAvLyAgICAgLy8gdXJsOiBzdHJpbmc7XG4gLy8gICAgIC8vIHNpemU6IG51bWJlcjtcbiAvLyAgICAgLy8gdXBsb2FkZWRBdDogRGF0ZTtcbiAvLyAgICAgLy8gbWV0YWRhdGE6IEluZmVyTWV0YWRhdGFPYmplY3Q8VEJ1Y2tldD47XG4gLy8gICAgIHBhdGg6IEluZmVyQnVja2V0UGF0aEtleXM8VEJ1Y2tldD4gZXh0ZW5kcyBzdHJpbmcgPyB7XG4gLy8gICAgICAgW2tleTogc3RyaW5nXTogc3RyaW5nO1xuIC8vICAgICB9IDp7XG4gLy8gICAgICAgW1RLZXkgaW4gSW5mZXJCdWNrZXRQYXRoS2V5czxUQnVja2V0Pl06IHN0cmluZztcbiAvLyAgICAgfTtcbiAvLyAgIH1bXTtcbiAvLyAgIHBhZ2luYXRpb246IHtcbiAvLyAgICAgY3VycmVudFBhZ2U6IG51bWJlcjtcbiAvLyAgICAgdG90YWxQYWdlczogbnVtYmVyO1xuIC8vICAgICB0b3RhbENvdW50OiBudW1iZXI7XG4gLy8gICB9O1xuIC8vIH07XG4gLy8gdHlwZSBUUGF0aEtleXMgPSAnYXV0aG9yJyB8ICd0eXBlJztcbiAvLyB0eXBlIFRQYXRoS2V5czIgPSBJbmZlckJ1Y2tldFBhdGhLZXlzPEFueUJ1aWxkZXI+O1xuIC8vIHR5cGUgT2JqZWN0V2l0aEtleXM8VEtleXMgZXh0ZW5kcyBzdHJpbmc+ID0ge1xuIC8vICAgW1RLZXkgaW4gVEtleXNdOiBzdHJpbmc7XG4gLy8gfTtcbiAvLyB0eXBlIFRlc3QxID0gT2JqZWN0V2l0aEtleXM8VFBhdGhLZXlzPjtcbiAvLyB0eXBlIFRlc3QyID0gT2JqZWN0V2l0aEtleXM8VFBhdGhLZXlzMj47XG4gLy8gdHlwZSBQYXRoS2V5cyA9IEluZmVyQnVja2V0UGF0aEtleXM8dHlwZW9mIHJvdXRlci5idWNrZXRzLmltYWdlQnVja2V0PjtcbiAvLyB0eXBlIE1ldGFkYXRhS2V5cyA9IEluZmVyTWV0YWRhdGFPYmplY3Q8dHlwZW9mIHJvdXRlci5idWNrZXRzLmltYWdlQnVja2V0PjtcbiAvLyB0eXBlIE15RWRnZVN0b3JlUm91dGVyID0gdHlwZW9mIHJvdXRlcjtcbiAvLyB0eXBlIE15QWNjZXNzQ29udHJvbCA9IEFjY2Vzc0NvbnRyb2xTY2hlbWE8Q29udGV4dCwgQW55RGVmPjtcblxuZXhwb3J0IHsgRURHRV9TVE9SRV9FUlJPUl9DT0RFUywgRWRnZVN0b3JlQXBpQ2xpZW50RXJyb3IsIEVkZ2VTdG9yZUVycm9yLCBpbml0RWRnZVN0b3JlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@edgestore/shared/dist/index.mjs\n");

/***/ })

};
;